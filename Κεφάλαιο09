# Υπολογισμός της αξίας της μετοχής χρησιμοποιώντας το μοντέλο μιας φάσης (μοντέλο των Gordon-Shapiro)
# εισάγουμε τα δεδομένα
D0 = 0.5 # το φετινό μέρισμα
g = 0.05 # ο ρυθμός αύξησης της πρώτης φάσης 
r = 0.12 # απαιτούμενη απόδοση 
# Υπολογισμός της παρούσας αξίας των μερισμάτων
stock_value = (D0*(1+g)) / (r - g)
# εμφάνιση αποτελέσματος
print(f"Η αξία της μετοχής ισούται με €{stock_value:.2f}")

# Υπολογισμός της αξίας της μετοχής χρησιμοποιώντας το μοντέλο δυο φάσεων εκτίμησης
# εισάγουμε τα δεδομένα
D0 = 1.2 # το φετινό μέρισμα
g1 = 0.1 # ο ρυθμός αύξησης της πρώτης φάσης 
n = 6 # αριθμός ετών της πρώτης φάσης
g2 = 0.03 # ο ρυθμός αύξησης της δεύτερης φάσης
r = 0.12 # απαιτούμενη απόδοση 
# Υπολογισμός της παρούσας αξίας των μερισμάτων της πρώτης φάσης
present_value_first_stage = sum(D0 * (1 + g1) ** t / (1 + r) ** t for t in range(1, n + 1))
# Υπολογισμός της παρούσας αξίας των μερισμάτων της δεύτερης φάσης
Dn = D0 * (1 + g1) ** n  # το μέρισμα στο τέλος της πρώτης φάσης
terminal_value = Dn * (1 + g2) / (r - g2)  # η αξία των μερισμάτων της δεύτερης φάσης στο τέλος της πρώτης φάσης
present_value_terminal = terminal_value / (1 + r) ** n  # η παρούσα αξία ων μερισμάτων της δεύτερης φάσης
# Η αξία της μετοχής είναι το άθροισμα της παρούσας αξίας των δύο φάσεων
stock_value = present_value_first_stage + present_value_terminal
# εμφάνιση αποτελέσματος
print(f"Η αξία της μετοχής ισούται με €{stock_value:.2f}")

# Ορισμός Συνάρτησης εκτίμησης της αξίας της μετοχής δυο φάσεων
def two_stage_dividend_model(D0, g1, n, g2, r):
    """
    υπολογίζουμε την αξία μιας μετοχής
    Μεταβλητές:
    D0 (float): το φετινό μέρισμα
    g1 (float): ο ρυθμός αύξησης της πρώτης φάσης (ως δεκαδικό)
    n (int): αριθμός ετών της πρώτης φάσης
    g2 (float): ο ρυθμός αύξησης της δεύτερης φάσης (ως δεκαδικό)
    r (float): απαιτούμενη απόδοση (κοινή και για τις δύο φάσεις)
    Αποτέλεσμα:
    float: η αξίας της μετοχής σε ευρώ
    """
    # Έλεγχος ότι ο ρυθμός αύξησης της δεύτερης φάσης είναι μικρότερος από την απαιτούμενη απόδοση
    if r <= g2:
        raise ValueError("Ο ρυθμός αύξησης της δεύτερης φάσης πρέπει να είναι μικρότερος από την απαιτούμενη απόδοση")
    # Υπολογισμός της παρούσας αξίας των μερισμάτων της πρώτης φάσης
    present_value_first_stage = sum(D0 * (1 + g1) ** t / (1 + r) ** t for t in range(1, n + 1))
    # Υπολογισμός της παρούσας αξίας των μερισμάτων της δεύτερης φάσης
    Dn = D0 * (1 + g1) ** n  # το μέρισμα στο τέλος της πρώτης φάσης
    terminal_value = Dn * (1 + g2) / (r - g2)  # η αξία των μερισμάτων της δεύτερης φάσης στο τέλος της πρώτης φάσης
    present_value_terminal = terminal_value / (1 + r) ** n  # η παρούσα αξία ων μερισμάτων της δεύτερης φάσης
    # Η αξία της μετοχής είναι το άθροισμα της παρούσας αξίας των δύο φάσεων
    stock_value = present_value_first_stage + present_value_terminal
    return print(f"Η αξία της μετοχής ισούται με €{stock_value:.2f}")

# Παράδειγμα 9-3
# Εισάγουμε τα δεδομένα
D0 = 1.5  # το φετινό μέρισμα
g1 = 0.2  # ο ρυθμός αύξησης της πρώτης φάσης
n1 = 3    # αριθμός ετών της πρώτης φάσης
g2 = 0.12 # ο ρυθμός αύξησης της δεύτερης φάσης
n2 = 3    # αριθμός ετών της δεύτερης φάσης
g3 = 0.07 # ο ρυθμός αύξησης της τρίτης φάσης
r = 0.14  # απαιτούμενη απόδοση
# Υπολογισμός της παρούσας αξίας των μερισμάτων της πρώτης φάσης
present_value_first_stage = sum(D0 * (1 + g1) ** t / (1 + r) ** t for t in range(1, n1 + 1))
# Υπολογισμός της παρούσας αξίας των μερισμάτων της δεύτερης φάσης
Dn1 = D0 * (1 + g1) ** n1
present_value_second_stage = sum(Dn1 * (1 + g2) ** t / (1 + r) ** (n1 + t) for t in range(1, n2 + 1))
# Υπολογισμός της αξίας της τελικής φάσης και της παρούσας αξίας της
Dn2 = Dn1 * (1 + g2) ** n2
terminal_value = Dn2 * (1 + g3) / (r - g3)
present_value_terminal = terminal_value / (1 + r) ** (n1 + n2)
# Η συνολική αξία της μετοχής είναι το άθροισμα των παρούσων αξιών των τριών φάσεων
stock_value = present_value_first_stage + present_value_second_stage + present_value_terminal
# Εμφάνιση αποτελέσματος
print(f"Η αξία της μετοχής ισούται με €{stock_value:.2f}")

# Ορισμός Συνάρτησης εκτίμησης της αξίας της μετοχής τριών φάσεων
def three_stage_dividend_model(D0, g1, n1, g2, n2, g3, r):
    """
    υπολογίζουμε την αξία μιας μετοχής
    Μεταβλητές:
    D0 (float): το φετινό μέρισμα
    g1 (float): ο ρυθμός αύξησης της πρώτης φάσης (ως δεκαδικό)
    n1 (int): αριθμός ετών της πρώτης φάσης
    g2 (float): ο ρυθμός αύξησης της δεύτερης φάσης (ως δεκαδικό)
    n2 (int): αριθμός ετών της δεύτερης φάσης
    g3 (float): ο ρυθμός αύξησης της τρίτης φάσης (ως δεκαδικό)
    r (float): απαιτούμενη απόδοση (κοινή και για τις τρεις φάσεις)
    Αποτέλεσμα:
    float: η αξίας της μετοχής σε ευρώ
    """
    # Έλεγχος ότι ο ρυθμός αύξησης της τρίτης φάσης είναι μικρότερος από την απαιτούμενη απόδοση
    if r <= g3:
        raise ValueError("Ο ρυθμός αύξησης της τρίτης φάσης πρέπει να είναι μικρότερος από την απαιτούμενη απόδοση")
    # Υπολογισμός της παρούσας αξίας των μερισμάτων της πρώτης φάσης
    present_value_first_stage = sum(D0 * (1 + g1) ** t / (1 + r) ** t for t in range(1, n1 + 1))
    # Υπολογισμός της παρούσας αξίας των μερισμάτων της δεύτερης φάσης
    Dn1 = D0 * (1 + g1) ** n1 # το μέρισμα στο τέλος της πρώτης φάσης
    present_value_second_stage = sum(Dn1 * (1 + g2) ** t / (1 + r) ** (n1 + t) for t in range(1, n2 + 1))
    # Υπολογισμός της παρούσας αξίας των μερισμάτων της τρίτης φάσης
    Dn2 = Dn1 * (1 + g2) ** n2 # το μέρισμα στο τέλος της δεύτερης φάσης
    terminal_value = Dn2 * (1 + g3) / (r - g3) # η αξία των μερισμάτων της τρίτης φάσης στο τέλος της δεύτερης φάσης
    present_value_terminal = terminal_value / (1 + r) ** (n1 + n2) # η παρούσα αξία των μερισμάτων της τρίτης φάσης
    # Η αξία της μετοχής είναι το άθροισμα της παρούσας αξίας των τριών φάσεων
    stock_value = present_value_first_stage + present_value_second_stage + present_value_terminal
    return print(f"Η αξία της μετοχής ισούται με €{stock_value:.2f}")
